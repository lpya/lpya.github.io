{"version":3,"sources":["webpack:///./node_modules/_three@0.149.0@three/examples/jsm/shaders/CopyShader.js","webpack:///./node_modules/_three@0.149.0@three/examples/jsm/postprocessing/RenderPass.js","webpack:///./node_modules/_three@0.149.0@three/examples/jsm/postprocessing/Pass.js","webpack:///./node_modules/_three@0.149.0@three/examples/jsm/postprocessing/OutlinePass.js","webpack:///./node_modules/_three@0.149.0@three/examples/jsm/postprocessing/ShaderPass.js","webpack:///./node_modules/_three@0.149.0@three/examples/jsm/postprocessing/MaskPass.js","webpack:///./node_modules/_three@0.149.0@three/examples/jsm/postprocessing/EffectComposer.js"],"names":["CopyShader","uniforms","value","vertexShader","fragmentShader","RenderPass","scene","camera","overrideMaterial","clearColor","clearAlpha","super","this","undefined","clear","clearDepth","needsSwap","_oldClearColor","renderer","writeBuffer","readBuffer","oldAutoClear","autoClear","oldClearAlpha","oldOverrideMaterial","getClearColor","getClearAlpha","setClearColor","setRenderTarget","renderToScreen","autoClearColor","autoClearDepth","autoClearStencil","render","Pass","enabled","console","error","_camera","_geometry","setAttribute","FullScreenQuad","material","_mesh","geometry","dispose","OutlinePass","resolution","selectedObjects","renderScene","renderCamera","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","x","y","resx","Math","round","resy","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","side","depthPacking","blending","prepareMaskMaterial","getPrepareMaskMaterial","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","getSeperableBlurMaterial","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","copyShader","string","type","isPerspectiveCamera","replace","copyUniforms","clone","materialCopy","depthTest","depthWrite","transparent","fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","width","height","setSize","bVisible","cache","gatherSelectedMeshesCallBack","object","isMesh","visible","get","i","length","selectedObject","traverse","selectedMeshes","push","VisibilityChangeCallBack","isSprite","bFound","selectedObjectId","id","visibility","isPoints","isLine","multiply","projectionMatrix","matrixWorldInverse","deltaTime","maskActive","state","buffers","stencil","setTest","changeVisibilityOfSelectedObjects","currentBackground","background","updateTextureMatrix","changeVisibilityOfNonSelectedObjects","near","far","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","maxRadius","defines","shader","textureID","Object","assign","inverse","context","getContext","writeValue","clearValue","color","setMask","depth","setLocked","setOp","REPLACE","setFunc","ALWAYS","setClear","EQUAL","KEEP","renderTarget","size","getSize","_pixelRatio","getPixelRatio","_width","_height","renderTarget1","renderTarget2","passes","copyPass","clock","tmp","pass","index","splice","indexOf","passIndex","getDelta","currentRenderTarget","getRenderTarget","il","isLastEnabledPass","NOTEQUAL","swapBuffers","effectiveWidth","effectiveHeight","pixelRatio"],"mappings":"kHAAA,kCAIA,MAAMA,EAAa,CAElBC,SAAU,CAET,SAAY,CAAEC,MAAO,MACrB,QAAW,CAAEA,MAAO,IAIrBC,aAAwB,8JAWxBC,eAA0B,qN,kCCxB3B,8DAKA,MAAMC,UAAmB,OAExB,YAAaC,EAAOC,EAAQC,EAAkBC,EAAYC,GAEzDC,QAEAC,KAAKN,MAAQA,EACbM,KAAKL,OAASA,EAEdK,KAAKJ,iBAAmBA,EAExBI,KAAKH,WAAaA,EAClBG,KAAKF,gBAA8BG,IAAfH,EAA6BA,EAAa,EAE9DE,KAAKE,OAAQ,EACbF,KAAKG,YAAa,EAClBH,KAAKI,WAAY,EACjBJ,KAAKK,eAAiB,IAAI,OAI3B,OAAQC,EAAUC,EAAaC,GAE9B,MAAMC,EAAeH,EAASI,UAG9B,IAAIC,EAAeC,EAFnBN,EAASI,WAAY,OAIUT,IAA1BD,KAAKJ,mBAETgB,EAAsBZ,KAAKN,MAAME,iBAEjCI,KAAKN,MAAME,iBAAmBI,KAAKJ,kBAI/BI,KAAKH,aAETS,EAASO,cAAeb,KAAKK,gBAC7BM,EAAgBL,EAASQ,gBAEzBR,EAASS,cAAef,KAAKH,WAAYG,KAAKF,aAI1CE,KAAKG,YAETG,EAASH,aAIVG,EAASU,gBAAiBhB,KAAKiB,eAAiB,KAAOT,GAGlDR,KAAKE,OAAQI,EAASJ,MAAOI,EAASY,eAAgBZ,EAASa,eAAgBb,EAASc,kBAC7Fd,EAASe,OAAQrB,KAAKN,MAAOM,KAAKL,QAE7BK,KAAKH,YAETS,EAASS,cAAef,KAAKK,eAAgBM,QAIfV,IAA1BD,KAAKJ,mBAETI,KAAKN,MAAME,iBAAmBgB,GAI/BN,EAASI,UAAYD,K,oCC1EvB,oFAOA,MAAMa,EAEL,cAGCtB,KAAKuB,SAAU,EAGfvB,KAAKI,WAAY,EAGjBJ,KAAKE,OAAQ,EAGbF,KAAKiB,gBAAiB,EAIvB,WAEA,SAECO,QAAQC,MAAO,8DAIhB,YAMD,MAAMC,EAAU,IAAI,QAAsB,EAAG,EAAG,GAAK,EAAG,EAAG,GAIrDC,EAAY,IAAI,OACtBA,EAAUC,aAAc,WAAY,IAAI,OAAwB,EAAI,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,EAAG,GAAK,IACvGD,EAAUC,aAAc,KAAM,IAAI,OAAwB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,GAAK,IAEhF,MAAMC,EAEL,YAAaC,GAEZ9B,KAAK+B,MAAQ,IAAI,OAAMJ,EAAWG,GAInC,UAEC9B,KAAK+B,MAAMC,SAASC,UAIrB,OAAQ3B,GAEPA,EAASe,OAAQrB,KAAK+B,MAAOL,GAI9B,eAEC,OAAO1B,KAAK+B,MAAMD,SAInB,aAAcxC,GAEbU,KAAK+B,MAAMD,SAAWxC,K,kCC3ExB,0EAiBA,MAAM4C,UAAoB,OAEzB,YAAaC,EAAYzC,EAAOC,EAAQyC,GAEvCrC,QAEAC,KAAKqC,YAAc3C,EACnBM,KAAKsC,aAAe3C,EACpBK,KAAKoC,qBAAsCnC,IAApBmC,EAAgCA,EAAkB,GACzEpC,KAAKuC,iBAAmB,IAAI,OAAO,EAAG,EAAG,GACzCvC,KAAKwC,gBAAkB,IAAI,OAAO,GAAK,IAAM,KAC7CxC,KAAKyC,SAAW,EAChBzC,KAAK0C,mBAAoB,EACzB1C,KAAK2C,cAAgB,EACrB3C,KAAK4C,aAAe,EACpB5C,KAAK6C,gBAAkB,EACvB7C,KAAK8C,YAAc,EAEnB9C,KAAK+C,iBAAmB,IAAIC,IAG5BhD,KAAKmC,gBAA8BlC,IAAfkC,EAA6B,IAAI,OAASA,EAAWc,EAAGd,EAAWe,GAAM,IAAI,OAAS,IAAK,KAE/G,MAAMC,EAAOC,KAAKC,MAAOrD,KAAKmC,WAAWc,EAAIjD,KAAK6C,iBAC5CS,EAAOF,KAAKC,MAAOrD,KAAKmC,WAAWe,EAAIlD,KAAK6C,iBAElD7C,KAAKuD,uBAAyB,IAAI,OAAmBvD,KAAKmC,WAAWc,EAAGjD,KAAKmC,WAAWe,GACxFlD,KAAKuD,uBAAuBC,QAAQC,KAAO,mBAC3CzD,KAAKuD,uBAAuBC,QAAQE,iBAAkB,EAEtD1D,KAAK2D,cAAgB,IAAI,OACzB3D,KAAK2D,cAAcC,KAAO,OAC1B5D,KAAK2D,cAAcE,aAAe,OAClC7D,KAAK2D,cAAcG,SAAW,OAE9B9D,KAAK+D,oBAAsB/D,KAAKgE,yBAChChE,KAAK+D,oBAAoBH,KAAO,OAChC5D,KAAK+D,oBAAoBvE,eAAiByE,EAAqBjE,KAAK+D,oBAAoBvE,eAAgBQ,KAAKsC,cAE7GtC,KAAKkE,wBAA0B,IAAI,OAAmBlE,KAAKmC,WAAWc,EAAGjD,KAAKmC,WAAWe,GACzFlD,KAAKkE,wBAAwBV,QAAQC,KAAO,oBAC5CzD,KAAKkE,wBAAwBV,QAAQE,iBAAkB,EAEvD1D,KAAKmE,iCAAmC,IAAI,OAAmBhB,EAAMG,GACrEtD,KAAKmE,iCAAiCX,QAAQC,KAAO,8BACrDzD,KAAKmE,iCAAiCX,QAAQE,iBAAkB,EAEhE1D,KAAKoE,wBAA0B,IAAI,OAAmBjB,EAAMG,GAC5DtD,KAAKoE,wBAAwBZ,QAAQC,KAAO,oBAC5CzD,KAAKoE,wBAAwBZ,QAAQE,iBAAkB,EACvD1D,KAAKqE,wBAA0B,IAAI,OAAmBjB,KAAKC,MAAOF,EAAO,GAAKC,KAAKC,MAAOC,EAAO,IACjGtD,KAAKqE,wBAAwBb,QAAQC,KAAO,oBAC5CzD,KAAKqE,wBAAwBb,QAAQE,iBAAkB,EAEvD1D,KAAKsE,sBAAwBtE,KAAKuE,2BAClCvE,KAAKwE,wBAA0B,IAAI,OAAmBrB,EAAMG,GAC5DtD,KAAKwE,wBAAwBhB,QAAQC,KAAO,oBAC5CzD,KAAKwE,wBAAwBhB,QAAQE,iBAAkB,EACvD1D,KAAKyE,wBAA0B,IAAI,OAAmBrB,KAAKC,MAAOF,EAAO,GAAKC,KAAKC,MAAOC,EAAO,IACjGtD,KAAKyE,wBAAwBjB,QAAQC,KAAO,oBAC5CzD,KAAKyE,wBAAwBjB,QAAQE,iBAAkB,EAEvD,MAAMgB,EAAqB,EACrBC,EAAgB,EAEtB3E,KAAK4E,uBAAyB5E,KAAK6E,yBAA0BH,GAC7D1E,KAAK4E,uBAAuBvF,SAAU,WAAYC,MAAMwF,IAAK3B,EAAMG,GACnEtD,KAAK4E,uBAAuBvF,SAAU,gBAAiBC,MAAQ,EAC/DU,KAAK+E,uBAAyB/E,KAAK6E,yBAA0BF,GAC7D3E,KAAK+E,uBAAuB1F,SAAU,WAAYC,MAAMwF,IAAK1B,KAAKC,MAAOF,EAAO,GAAKC,KAAKC,MAAOC,EAAO,IACxGtD,KAAK+E,uBAAuB1F,SAAU,gBAAiBC,MAAQqF,EAG/D3E,KAAKgF,gBAAkBhF,KAAKiF,qBAI5B,MAAMC,EAAa,OA2BnB,SAASjB,EAAqBkB,EAAQxF,GAErC,MAAMyF,EAAOzF,EAAO0F,oBAAsB,cAAgB,eAE1D,OAAOF,EAAOG,QAAS,mBAAoBF,EAAO,gBA7BnDpF,KAAKuF,aAAe,OAAcC,MAAON,EAAW7F,UACpDW,KAAKuF,aAAc,WAAYjG,MAAQ,EAEvCU,KAAKyF,aAAe,IAAI,OAAgB,CACvCpG,SAAUW,KAAKuF,aACfhG,aAAc2F,EAAW3F,aACzBC,eAAgB0F,EAAW1F,eAC3BsE,SAAU,OACV4B,WAAW,EACXC,YAAY,EACZC,aAAa,IAGd5F,KAAKuB,SAAU,EACfvB,KAAKI,WAAY,EAEjBJ,KAAKK,eAAiB,IAAI,OAC1BL,KAAKW,cAAgB,EAErBX,KAAK6F,OAAS,IAAI,OAAgB,MAElC7F,KAAK8F,gBAAkB,IAAI,OAC3B9F,KAAK+F,gBAAkB,IAAI,OAC3B/F,KAAKgG,cAAgB,IAAI,OAY1B,UAEChG,KAAKuD,uBAAuBtB,UAC5BjC,KAAKkE,wBAAwBjC,UAC7BjC,KAAKmE,iCAAiClC,UACtCjC,KAAKoE,wBAAwBnC,UAC7BjC,KAAKqE,wBAAwBpC,UAC7BjC,KAAKwE,wBAAwBvC,UAC7BjC,KAAKyE,wBAAwBxC,UAE7BjC,KAAK2D,cAAc1B,UACnBjC,KAAK+D,oBAAoB9B,UACzBjC,KAAKsE,sBAAsBrC,UAC3BjC,KAAK4E,uBAAuB3C,UAC5BjC,KAAK+E,uBAAuB9C,UAC5BjC,KAAKgF,gBAAgB/C,UACrBjC,KAAKyF,aAAaxD,UAElBjC,KAAK6F,OAAO5D,UAIb,QAASgE,EAAOC,GAEflG,KAAKuD,uBAAuB4C,QAASF,EAAOC,GAC5ClG,KAAKkE,wBAAwBiC,QAASF,EAAOC,GAE7C,IAAI/C,EAAOC,KAAKC,MAAO4C,EAAQjG,KAAK6C,iBAChCS,EAAOF,KAAKC,MAAO6C,EAASlG,KAAK6C,iBACrC7C,KAAKmE,iCAAiCgC,QAAShD,EAAMG,GACrDtD,KAAKoE,wBAAwB+B,QAAShD,EAAMG,GAC5CtD,KAAKwE,wBAAwB2B,QAAShD,EAAMG,GAC5CtD,KAAK4E,uBAAuBvF,SAAU,WAAYC,MAAMwF,IAAK3B,EAAMG,GAEnEH,EAAOC,KAAKC,MAAOF,EAAO,GAC1BG,EAAOF,KAAKC,MAAOC,EAAO,GAE1BtD,KAAKqE,wBAAwB8B,QAAShD,EAAMG,GAC5CtD,KAAKyE,wBAAwB0B,QAAShD,EAAMG,GAE5CtD,KAAK+E,uBAAuB1F,SAAU,WAAYC,MAAMwF,IAAK3B,EAAMG,GAIpE,kCAAmC8C,GAElC,MAAMC,EAAQrG,KAAK+C,iBAEnB,SAASuD,EAA8BC,GAEjCA,EAAOC,UAEO,IAAbJ,EAEJG,EAAOE,QAAUJ,EAAMK,IAAKH,IAI5BF,EAAMvB,IAAKyB,EAAQA,EAAOE,SAC1BF,EAAOE,QAAUL,IAQpB,IAAM,IAAIO,EAAI,EAAGA,EAAI3G,KAAKoC,gBAAgBwE,OAAQD,IAAO,CAExD,MAAME,EAAiB7G,KAAKoC,gBAAiBuE,GAC7CE,EAAeC,SAAUR,IAM3B,qCAAsCF,GAErC,MAAMC,EAAQrG,KAAK+C,iBACbgE,EAAiB,GAEvB,SAAST,EAA8BC,GAEjCA,EAAOC,QAASO,EAAeC,KAAMT,GAI3C,IAAM,IAAII,EAAI,EAAGA,EAAI3G,KAAKoC,gBAAgBwE,OAAQD,IAAO,CAExD,MAAME,EAAiB7G,KAAKoC,gBAAiBuE,GAC7CE,EAAeC,SAAUR,GAI1B,SAASW,EAA0BV,GAElC,GAAKA,EAAOC,QAAUD,EAAOW,SAAW,CAIvC,IAAIC,GAAS,EAEb,IAAM,IAAIR,EAAI,EAAGA,EAAII,EAAeH,OAAQD,IAAO,CAElD,MAAMS,EAAmBL,EAAgBJ,GAAIU,GAE7C,GAAKD,IAAqBb,EAAOc,GAAK,CAErCF,GAAS,EACT,OAMF,IAAgB,IAAXA,EAAmB,CAEvB,MAAMG,EAAaf,EAAOE,SAER,IAAbL,IAA8C,IAAxBC,EAAMK,IAAKH,KAErCA,EAAOE,QAAUL,GAIlBC,EAAMvB,IAAKyB,EAAQe,SAITf,EAAOgB,UAAYhB,EAAOiB,WAKnB,IAAbpB,EAEJG,EAAOE,QAAUJ,EAAMK,IAAKH,IAI5BF,EAAMvB,IAAKyB,EAAQA,EAAOE,SAC1BF,EAAOE,QAAUL,IAQpBpG,KAAKqC,YAAYyE,SAAUG,GAI5B,sBAECjH,KAAKgG,cAAclB,IAAK,GAAK,EAAK,EAAK,GACtC,EAAK,GAAK,EAAK,GACf,EAAK,EAAK,GAAK,GACf,EAAK,EAAK,EAAK,GAChB9E,KAAKgG,cAAcyB,SAAUzH,KAAKsC,aAAaoF,kBAC/C1H,KAAKgG,cAAcyB,SAAUzH,KAAKsC,aAAaqF,oBAIhD,OAAQrH,EAAUC,EAAaC,EAAYoH,EAAWC,GAErD,GAAK7H,KAAKoC,gBAAgBwE,OAAS,EAAI,CAEtCtG,EAASO,cAAeb,KAAKK,gBAC7BL,KAAKW,cAAgBL,EAASQ,gBAC9B,MAAML,EAAeH,EAASI,UAE9BJ,EAASI,WAAY,EAEhBmH,GAAavH,EAASwH,MAAMC,QAAQC,QAAQC,SAAS,GAE1D3H,EAASS,cAAe,SAAU,GAGlCf,KAAKkI,mCAAmC,GAExC,MAAMC,EAAoBnI,KAAKqC,YAAY+F,WAyC3C,GAxCApI,KAAKqC,YAAY+F,WAAa,KAG9BpI,KAAKqC,YAAYzC,iBAAmBI,KAAK2D,cACzCrD,EAASU,gBAAiBhB,KAAKkE,yBAC/B5D,EAASJ,QACTI,EAASe,OAAQrB,KAAKqC,YAAarC,KAAKsC,cAGxCtC,KAAKkI,mCAAmC,GACxClI,KAAK+C,iBAAiB7C,QAGtBF,KAAKqI,sBAGLrI,KAAKsI,sCAAsC,GAC3CtI,KAAKqC,YAAYzC,iBAAmBI,KAAK+D,oBACzC/D,KAAK+D,oBAAoB1E,SAAU,iBAAkBC,MAAMwF,IAAK9E,KAAKsC,aAAaiG,KAAMvI,KAAKsC,aAAakG,KAC1GxI,KAAK+D,oBAAoB1E,SAAU,gBAAiBC,MAAQU,KAAKkE,wBAAwBV,QACzFxD,KAAK+D,oBAAoB1E,SAAU,iBAAkBC,MAAQU,KAAKgG,cAClE1F,EAASU,gBAAiBhB,KAAKuD,wBAC/BjD,EAASJ,QACTI,EAASe,OAAQrB,KAAKqC,YAAarC,KAAKsC,cACxCtC,KAAKqC,YAAYzC,iBAAmB,KACpCI,KAAKsI,sCAAsC,GAC3CtI,KAAK+C,iBAAiB7C,QAEtBF,KAAKqC,YAAY+F,WAAaD,EAG9BnI,KAAK6F,OAAO/D,SAAW9B,KAAKyF,aAC5BzF,KAAKuF,aAAc,YAAajG,MAAQU,KAAKuD,uBAAuBC,QACpElD,EAASU,gBAAiBhB,KAAKmE,kCAC/B7D,EAASJ,QACTF,KAAK6F,OAAOxE,OAAQf,GAEpBN,KAAK8F,gBAAgB2C,KAAMzI,KAAKuC,kBAChCvC,KAAK+F,gBAAgB0C,KAAMzI,KAAKwC,iBAE3BxC,KAAK8C,YAAc,EAAI,CAE3B,MAAM4F,EAAS,KAA6E,IAA1DtF,KAAKuF,IAAyB,IAApBC,YAAYC,MAAe7I,KAAK8C,aAAiC,EAC7G9C,KAAK8F,gBAAgBgD,eAAgBJ,GACrC1I,KAAK+F,gBAAgB+C,eAAgBJ,GAKtC1I,KAAK6F,OAAO/D,SAAW9B,KAAKsE,sBAC5BtE,KAAKsE,sBAAsBjF,SAAU,eAAgBC,MAAQU,KAAKmE,iCAAiCX,QACnGxD,KAAKsE,sBAAsBjF,SAAU,WAAYC,MAAMwF,IAAK9E,KAAKmE,iCAAiC8B,MAAOjG,KAAKmE,iCAAiC+B,QAC/IlG,KAAKsE,sBAAsBjF,SAAU,oBAAqBC,MAAQU,KAAK8F,gBACvE9F,KAAKsE,sBAAsBjF,SAAU,mBAAoBC,MAAQU,KAAK+F,gBACtEzF,EAASU,gBAAiBhB,KAAKwE,yBAC/BlE,EAASJ,QACTF,KAAK6F,OAAOxE,OAAQf,GAGpBN,KAAK6F,OAAO/D,SAAW9B,KAAK4E,uBAC5B5E,KAAK4E,uBAAuBvF,SAAU,gBAAiBC,MAAQU,KAAKwE,wBAAwBhB,QAC5FxD,KAAK4E,uBAAuBvF,SAAU,aAAcC,MAAQ4C,EAAY6G,eACxE/I,KAAK4E,uBAAuBvF,SAAU,gBAAiBC,MAAQU,KAAK2C,cACpErC,EAASU,gBAAiBhB,KAAKoE,yBAC/B9D,EAASJ,QACTF,KAAK6F,OAAOxE,OAAQf,GACpBN,KAAK4E,uBAAuBvF,SAAU,gBAAiBC,MAAQU,KAAKoE,wBAAwBZ,QAC5FxD,KAAK4E,uBAAuBvF,SAAU,aAAcC,MAAQ4C,EAAY8G,eACxE1I,EAASU,gBAAiBhB,KAAKwE,yBAC/BlE,EAASJ,QACTF,KAAK6F,OAAOxE,OAAQf,GAGpBN,KAAK6F,OAAO/D,SAAW9B,KAAK+E,uBAC5B/E,KAAK+E,uBAAuB1F,SAAU,gBAAiBC,MAAQU,KAAKwE,wBAAwBhB,QAC5FxD,KAAK+E,uBAAuB1F,SAAU,aAAcC,MAAQ4C,EAAY6G,eACxEzI,EAASU,gBAAiBhB,KAAKqE,yBAC/B/D,EAASJ,QACTF,KAAK6F,OAAOxE,OAAQf,GACpBN,KAAK+E,uBAAuB1F,SAAU,gBAAiBC,MAAQU,KAAKqE,wBAAwBb,QAC5FxD,KAAK+E,uBAAuB1F,SAAU,aAAcC,MAAQ4C,EAAY8G,eACxE1I,EAASU,gBAAiBhB,KAAKyE,yBAC/BnE,EAASJ,QACTF,KAAK6F,OAAOxE,OAAQf,GAGpBN,KAAK6F,OAAO/D,SAAW9B,KAAKgF,gBAC5BhF,KAAKgF,gBAAgB3F,SAAU,eAAgBC,MAAQU,KAAKuD,uBAAuBC,QACnFxD,KAAKgF,gBAAgB3F,SAAU,gBAAiBC,MAAQU,KAAKwE,wBAAwBhB,QACrFxD,KAAKgF,gBAAgB3F,SAAU,gBAAiBC,MAAQU,KAAKyE,wBAAwBjB,QACrFxD,KAAKgF,gBAAgB3F,SAAU,kBAAmBC,MAAQU,KAAKiJ,eAC/DjJ,KAAKgF,gBAAgB3F,SAAU,gBAAiBC,MAAQU,KAAK4C,aAC7D5C,KAAKgF,gBAAgB3F,SAAU,YAAaC,MAAQU,KAAKyC,SACzDzC,KAAKgF,gBAAgB3F,SAAU,qBAAsBC,MAAQU,KAAK0C,kBAG7DmF,GAAavH,EAASwH,MAAMC,QAAQC,QAAQC,SAAS,GAE1D3H,EAASU,gBAAiBR,GAC1BR,KAAK6F,OAAOxE,OAAQf,GAEpBA,EAASS,cAAef,KAAKK,eAAgBL,KAAKW,eAClDL,EAASI,UAAYD,EAIjBT,KAAKiB,iBAETjB,KAAK6F,OAAO/D,SAAW9B,KAAKyF,aAC5BzF,KAAKuF,aAAc,YAAajG,MAAQkB,EAAWgD,QACnDlD,EAASU,gBAAiB,MAC1BhB,KAAK6F,OAAOxE,OAAQf,IAMtB,yBAEC,OAAO,IAAI,OAAgB,CAE1BjB,SAAU,CACT,aAAgB,CAAEC,MAAO,MACzB,cAAiB,CAAEA,MAAO,IAAI,OAAS,GAAK,KAC5C,cAAiB,CAAEA,MAAO,OAG3BC,aACC,qvBA+BDC,eACC,6fAmBH,2BAEC,OAAO,IAAI,OAAgB,CAE1BH,SAAU,CACT,YAAe,CAAEC,MAAO,MACxB,QAAW,CAAEA,MAAO,IAAI,OAAS,GAAK,KACtC,iBAAoB,CAAEA,MAAO,IAAI,OAAS,EAAK,EAAK,IACpD,gBAAmB,CAAEA,MAAO,IAAI,OAAS,EAAK,EAAK,KAGpDC,aACC,kKAODC,eACC,k/BA2BH,yBAA0B0J,GAEzB,OAAO,IAAI,OAAgB,CAE1BC,QAAS,CACR,WAAcD,GAGf7J,SAAU,CACT,aAAgB,CAAEC,MAAO,MACzB,QAAW,CAAEA,MAAO,IAAI,OAAS,GAAK,KACtC,UAAa,CAAEA,MAAO,IAAI,OAAS,GAAK,KACxC,aAAgB,CAAEA,MAAO,IAG1BC,aACC,kKAODC,eACC,6pCAiCH,qBAEC,OAAO,IAAI,OAAgB,CAE1BH,SAAU,CACT,YAAe,CAAEC,MAAO,MACxB,aAAgB,CAAEA,MAAO,MACzB,aAAgB,CAAEA,MAAO,MACzB,eAAkB,CAAEA,MAAO,MAC3B,aAAgB,CAAEA,MAAO,GACzB,SAAY,CAAEA,MAAO,GACrB,kBAAqB,CAAEA,MAAO,IAG/BC,aACC,kKAODC,eACC,q7BAsBDsE,SAAU,OACV4B,WAAW,EACXC,YAAY,EACZC,aAAa,KAOhB1D,EAAY6G,eAAiB,IAAI,OAAS,EAAK,GAC/C7G,EAAY8G,eAAiB,IAAI,OAAS,EAAK,I,8GCtoB/C,MAAM,UAAmB1H,EAAA,KAExB,YAAa8H,EAAQC,GAEpBtJ,QAEAC,KAAKqJ,eAA4BpJ,IAAdoJ,EAA4BA,EAAY,WAEtDD,aAAkB,QAEtBpJ,KAAKX,SAAW+J,EAAO/J,SAEvBW,KAAK8B,SAAWsH,GAELA,IAEXpJ,KAAKX,SAAW,OAAcmG,MAAO4D,EAAO/J,UAE5CW,KAAK8B,SAAW,IAAI,OAAgB,CAEnCqH,QAASG,OAAOC,OAAQ,GAAIH,EAAOD,SACnC9J,SAAUW,KAAKX,SACfE,aAAc6J,EAAO7J,aACrBC,eAAgB4J,EAAO5J,kBAMzBQ,KAAK6F,OAAS,IAAI,OAAgB7F,KAAK8B,UAIxC,OAAQxB,EAAUC,EAAaC,GAEzBR,KAAKX,SAAUW,KAAKqJ,aAExBrJ,KAAKX,SAAUW,KAAKqJ,WAAY/J,MAAQkB,EAAWgD,SAIpDxD,KAAK6F,OAAO/D,SAAW9B,KAAK8B,SAEvB9B,KAAKiB,gBAETX,EAASU,gBAAiB,MAC1BhB,KAAK6F,OAAOxE,OAAQf,KAIpBA,EAASU,gBAAiBT,GAErBP,KAAKE,OAAQI,EAASJ,MAAOI,EAASY,eAAgBZ,EAASa,eAAgBb,EAASc,kBAC7FpB,KAAK6F,OAAOxE,OAAQf,IAMtB,UAECN,KAAK8B,SAASG,UAEdjC,KAAK6F,OAAO5D,WCnEd,MAAM,UAAiBX,EAAA,KAEtB,YAAa5B,EAAOC,GAEnBI,QAEAC,KAAKN,MAAQA,EACbM,KAAKL,OAASA,EAEdK,KAAKE,OAAQ,EACbF,KAAKI,WAAY,EAEjBJ,KAAKwJ,SAAU,EAIhB,OAAQlJ,EAAUC,EAAaC,GAE9B,MAAMiJ,EAAUnJ,EAASoJ,aACnB5B,EAAQxH,EAASwH,MAcvB,IAAI6B,EAAYC,EAVhB9B,EAAMC,QAAQ8B,MAAMC,SAAS,GAC7BhC,EAAMC,QAAQgC,MAAMD,SAAS,GAI7BhC,EAAMC,QAAQ8B,MAAMG,WAAW,GAC/BlC,EAAMC,QAAQgC,MAAMC,WAAW,GAM1BhK,KAAKwJ,SAETG,EAAa,EACbC,EAAa,IAIbD,EAAa,EACbC,EAAa,GAId9B,EAAMC,QAAQC,QAAQC,SAAS,GAC/BH,EAAMC,QAAQC,QAAQiC,MAAOR,EAAQS,QAAST,EAAQS,QAAST,EAAQS,SACvEpC,EAAMC,QAAQC,QAAQmC,QAASV,EAAQW,OAAQT,EAAY,YAC3D7B,EAAMC,QAAQC,QAAQqC,SAAUT,GAChC9B,EAAMC,QAAQC,QAAQgC,WAAW,GAIjC1J,EAASU,gBAAiBR,GACrBR,KAAKE,OAAQI,EAASJ,QAC3BI,EAASe,OAAQrB,KAAKN,MAAOM,KAAKL,QAElCW,EAASU,gBAAiBT,GACrBP,KAAKE,OAAQI,EAASJ,QAC3BI,EAASe,OAAQrB,KAAKN,MAAOM,KAAKL,QAIlCmI,EAAMC,QAAQ8B,MAAMG,WAAW,GAC/BlC,EAAMC,QAAQgC,MAAMC,WAAW,GAI/BlC,EAAMC,QAAQC,QAAQgC,WAAW,GACjClC,EAAMC,QAAQC,QAAQmC,QAASV,EAAQa,MAAO,EAAG,YACjDxC,EAAMC,QAAQC,QAAQiC,MAAOR,EAAQc,KAAMd,EAAQc,KAAMd,EAAQc,MACjEzC,EAAMC,QAAQC,QAAQgC,WAAW,IAMnC,MAAM,UAAsB1I,EAAA,KAE3B,cAECvB,QAEAC,KAAKI,WAAY,EAIlB,OAAQE,GAEPA,EAASwH,MAAMC,QAAQC,QAAQgC,WAAW,GAC1C1J,EAASwH,MAAMC,QAAQC,QAAQC,SAAS,ICpF1C,MAAM,EAEL,YAAa3H,EAAUkK,GAItB,GAFAxK,KAAKM,SAAWA,OAEML,IAAjBuK,EAA6B,CAEjC,MAAMC,EAAOnK,EAASoK,QAAS,IAAI,QACnC1K,KAAK2K,YAAcrK,EAASsK,gBAC5B5K,KAAK6K,OAASJ,EAAKxE,MACnBjG,KAAK8K,QAAUL,EAAKvE,OAEpBsE,EAAe,IAAI,OAAmBxK,KAAK6K,OAAS7K,KAAK2K,YAAa3K,KAAK8K,QAAU9K,KAAK2K,aAC1FH,EAAahH,QAAQC,KAAO,0BAI5BzD,KAAK2K,YAAc,EACnB3K,KAAK6K,OAASL,EAAavE,MAC3BjG,KAAK8K,QAAUN,EAAatE,OAI7BlG,KAAK+K,cAAgBP,EACrBxK,KAAKgL,cAAgBR,EAAahF,QAClCxF,KAAKgL,cAAcxH,QAAQC,KAAO,qBAElCzD,KAAKO,YAAcP,KAAK+K,cACxB/K,KAAKQ,WAAaR,KAAKgL,cAEvBhL,KAAKiB,gBAAiB,EAEtBjB,KAAKiL,OAAS,GAEdjL,KAAKkL,SAAW,IAAI,EAAY9L,EAAA,MAEhCY,KAAKmL,MAAQ,IAAI,OAIlB,cAEC,MAAMC,EAAMpL,KAAKQ,WACjBR,KAAKQ,WAAaR,KAAKO,YACvBP,KAAKO,YAAc6K,EAIpB,QAASC,GAERrL,KAAKiL,OAAOjE,KAAMqE,GAClBA,EAAKlF,QAASnG,KAAK6K,OAAS7K,KAAK2K,YAAa3K,KAAK8K,QAAU9K,KAAK2K,aAInE,WAAYU,EAAMC,GAEjBtL,KAAKiL,OAAOM,OAAQD,EAAO,EAAGD,GAC9BA,EAAKlF,QAASnG,KAAK6K,OAAS7K,KAAK2K,YAAa3K,KAAK8K,QAAU9K,KAAK2K,aAInE,WAAYU,GAEX,MAAMC,EAAQtL,KAAKiL,OAAOO,QAASH,IAElB,IAAZC,GAEJtL,KAAKiL,OAAOM,OAAQD,EAAO,GAM7B,kBAAmBG,GAElB,IAAM,IAAI9E,EAAI8E,EAAY,EAAG9E,EAAI3G,KAAKiL,OAAOrE,OAAQD,IAEpD,GAAK3G,KAAKiL,OAAQtE,GAAIpF,QAErB,OAAO,EAMT,OAAO,EAIR,OAAQqG,QAIY3H,IAAd2H,IAEJA,EAAY5H,KAAKmL,MAAMO,YAIxB,MAAMC,EAAsB3L,KAAKM,SAASsL,kBAE1C,IAAI/D,GAAa,EAEjB,IAAM,IAAIlB,EAAI,EAAGkF,EAAK7L,KAAKiL,OAAOrE,OAAQD,EAAIkF,EAAIlF,IAAO,CAExD,MAAM0E,EAAOrL,KAAKiL,OAAQtE,GAE1B,IAAsB,IAAjB0E,EAAK9J,QAAV,CAKA,GAHA8J,EAAKpK,eAAmBjB,KAAKiB,gBAAkBjB,KAAK8L,kBAAmBnF,GACvE0E,EAAKhK,OAAQrB,KAAKM,SAAUN,KAAKO,YAAaP,KAAKQ,WAAYoH,EAAWC,GAErEwD,EAAKjL,UAAY,CAErB,GAAKyH,EAAa,CAEjB,MAAM4B,EAAUzJ,KAAKM,SAASoJ,aACxB1B,EAAUhI,KAAKM,SAASwH,MAAMC,QAAQC,QAG5CA,EAAQmC,QAASV,EAAQsC,SAAU,EAAG,YAEtC/L,KAAKkL,SAAS7J,OAAQrB,KAAKM,SAAUN,KAAKO,YAAaP,KAAKQ,WAAYoH,GAGxEI,EAAQmC,QAASV,EAAQa,MAAO,EAAG,YAIpCtK,KAAKgM,mBAIY/L,IAAb,IAECoL,aAAgB,EAEpBxD,GAAa,EAEFwD,aAAgB,IAE3BxD,GAAa,KAQhB7H,KAAKM,SAASU,gBAAiB2K,GAIhC,MAAOnB,GAEN,QAAsBvK,IAAjBuK,EAA6B,CAEjC,MAAMC,EAAOzK,KAAKM,SAASoK,QAAS,IAAI,QACxC1K,KAAK2K,YAAc3K,KAAKM,SAASsK,gBACjC5K,KAAK6K,OAASJ,EAAKxE,MACnBjG,KAAK8K,QAAUL,EAAKvE,OAEpBsE,EAAexK,KAAK+K,cAAcvF,QAClCgF,EAAarE,QAASnG,KAAK6K,OAAS7K,KAAK2K,YAAa3K,KAAK8K,QAAU9K,KAAK2K,aAI3E3K,KAAK+K,cAAc9I,UACnBjC,KAAKgL,cAAc/I,UACnBjC,KAAK+K,cAAgBP,EACrBxK,KAAKgL,cAAgBR,EAAahF,QAElCxF,KAAKO,YAAcP,KAAK+K,cACxB/K,KAAKQ,WAAaR,KAAKgL,cAIxB,QAAS/E,EAAOC,GAEflG,KAAK6K,OAAS5E,EACdjG,KAAK8K,QAAU5E,EAEf,MAAM+F,EAAiBjM,KAAK6K,OAAS7K,KAAK2K,YACpCuB,EAAkBlM,KAAK8K,QAAU9K,KAAK2K,YAE5C3K,KAAK+K,cAAc5E,QAAS8F,EAAgBC,GAC5ClM,KAAKgL,cAAc7E,QAAS8F,EAAgBC,GAE5C,IAAM,IAAIvF,EAAI,EAAGA,EAAI3G,KAAKiL,OAAOrE,OAAQD,IAExC3G,KAAKiL,OAAQtE,GAAIR,QAAS8F,EAAgBC,GAM5C,cAAeC,GAEdnM,KAAK2K,YAAcwB,EAEnBnM,KAAKmG,QAASnG,KAAK6K,OAAQ7K,KAAK8K,SAIjC,UAEC9K,KAAK+K,cAAc9I,UACnBjC,KAAKgL,cAAc/I,UAEnBjC,KAAKkL,SAASjJ","file":"js/chunk-1ab52ae4.9536895a.js","sourcesContent":["/**\n * Full-screen textured quad shader\n */\n\nconst CopyShader = {\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'opacity': { value: 1.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}`\n\n};\n\nexport { CopyShader };\n","import {\n\tColor\n} from 'three';\nimport { Pass } from './Pass.js';\n\nclass RenderPass extends Pass {\n\n\tconstructor( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\n\n\t\tsuper();\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.overrideMaterial = overrideMaterial;\n\n\t\tthis.clearColor = clearColor;\n\t\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\n\n\t\tthis.clear = true;\n\t\tthis.clearDepth = false;\n\t\tthis.needsSwap = false;\n\t\tthis._oldClearColor = new Color();\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tlet oldClearAlpha, oldOverrideMaterial;\n\n\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\toldOverrideMaterial = this.scene.overrideMaterial;\n\n\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t}\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\n\t\t}\n\n\t\tif ( this.clearDepth ) {\n\n\t\t\trenderer.clearDepth();\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\n\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\trenderer.render( this.scene, this.camera );\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.setClearColor( this._oldClearColor, oldClearAlpha );\n\n\t\t}\n\n\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\n\t\t}\n\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n}\n\nexport { RenderPass };\n","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nconst _geometry = new BufferGeometry();\n_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import {\n\tAdditiveBlending,\n\tColor,\n\tDoubleSide,\n\tMatrix4,\n\tMeshDepthMaterial,\n\tNoBlending,\n\tRGBADepthPacking,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nclass OutlinePass extends Pass {\n\n\tconstructor( resolution, scene, camera, selectedObjects ) {\n\n\t\tsuper();\n\n\t\tthis.renderScene = scene;\n\t\tthis.renderCamera = camera;\n\t\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\t\tthis.visibleEdgeColor = new Color( 1, 1, 1 );\n\t\tthis.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );\n\t\tthis.edgeGlow = 0.0;\n\t\tthis.usePatternTexture = false;\n\t\tthis.edgeThickness = 1.0;\n\t\tthis.edgeStrength = 3.0;\n\t\tthis.downSampleRatio = 2;\n\t\tthis.pulsePeriod = 0;\n\n\t\tthis._visibilityCache = new Map();\n\n\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\tconst resx = Math.round( this.resolution.x / this.downSampleRatio );\n\t\tconst resy = Math.round( this.resolution.y / this.downSampleRatio );\n\n\t\tthis.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );\n\t\tthis.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n\t\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\t\tthis.depthMaterial = new MeshDepthMaterial();\n\t\tthis.depthMaterial.side = DoubleSide;\n\t\tthis.depthMaterial.depthPacking = RGBADepthPacking;\n\t\tthis.depthMaterial.blending = NoBlending;\n\n\t\tthis.prepareMaskMaterial = this.getPrepareMaskMaterial();\n\t\tthis.prepareMaskMaterial.side = DoubleSide;\n\t\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\n\n\t\tthis.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );\n\t\tthis.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n\t\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n\t\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n\t\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\t\tthis.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n\t\tthis.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n\t\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n\t\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\t\tconst MAX_EDGE_THICKNESS = 4;\n\t\tconst MAX_EDGE_GLOW = 4;\n\n\t\tthis.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = 1;\n\t\tthis.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.separableBlurMaterial2.uniforms[ 'kernelRadius' ].value = MAX_EDGE_GLOW;\n\n\t\t// Overlay material\n\t\tthis.overlayMaterial = this.getOverlayMaterial();\n\n\t\t// copy material\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t\tthis.tempPulseColor1 = new Color();\n\t\tthis.tempPulseColor2 = new Color();\n\t\tthis.textureMatrix = new Matrix4();\n\n\t\tfunction replaceDepthToViewZ( string, camera ) {\n\n\t\t\tconst type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.renderTargetMaskBuffer.dispose();\n\t\tthis.renderTargetDepthBuffer.dispose();\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\tthis.renderTargetEdgeBuffer2.dispose();\n\n\t\tthis.depthMaterial.dispose();\n\t\tthis.prepareMaskMaterial.dispose();\n\t\tthis.edgeDetectionMaterial.dispose();\n\t\tthis.separableBlurMaterial1.dispose();\n\t\tthis.separableBlurMaterial2.dispose();\n\t\tthis.overlayMaterial.dispose();\n\t\tthis.materialCopy.dispose();\n\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis.renderTargetMaskBuffer.setSize( width, height );\n\t\tthis.renderTargetDepthBuffer.setSize( width, height );\n\n\t\tlet resx = Math.round( width / this.downSampleRatio );\n\t\tlet resy = Math.round( height / this.downSampleRatio );\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t\tresx = Math.round( resx / 2 );\n\t\tresy = Math.round( resy / 2 );\n\n\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\n\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t}\n\n\tchangeVisibilityOfSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = cache.get( object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t}\n\n\tchangeVisibilityOfNonSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\t\tconst selectedMeshes = [];\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) selectedMeshes.push( object );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t\tfunction VisibilityChangeCallBack( object ) {\n\n\t\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\t\t// only meshes and sprites are supported by OutlinePass\n\n\t\t\t\tlet bFound = false;\n\n\t\t\t\tfor ( let i = 0; i < selectedMeshes.length; i ++ ) {\n\n\t\t\t\t\tconst selectedObjectId = selectedMeshes[ i ].id;\n\n\t\t\t\t\tif ( selectedObjectId === object.id ) {\n\n\t\t\t\t\t\tbFound = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( bFound === false ) {\n\n\t\t\t\t\tconst visibility = object.visible;\n\n\t\t\t\t\tif ( bVisible === false || cache.get( object ) === true ) {\n\n\t\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcache.set( object, visibility );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints || object.isLine ) {\n\n\t\t\t\t// the visibilty of points and lines is always set to false in order to\n\t\t\t\t// not affect the outline computation\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = cache.get( object ); // restore\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\n\n\t}\n\n\tupdateTextureMatrix() {\n\n\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0 );\n\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\n\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tif ( this.selectedObjects.length > 0 ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tconst oldAutoClear = renderer.autoClear;\n\n\t\t\trenderer.autoClear = false;\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\t\t// Make selected objects invisible\n\t\t\tthis.changeVisibilityOfSelectedObjects( false );\n\n\t\t\tconst currentBackground = this.renderScene.background;\n\t\t\tthis.renderScene.background = null;\n\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\trenderer.setRenderTarget( this.renderTargetDepthBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\n\t\t\t// Make selected objects visible\n\t\t\tthis.changeVisibilityOfSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\t// Update Texture Matrix for Depth compare\n\t\t\tthis.updateTextureMatrix();\n\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( false );\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'cameraNearFar' ].value.set( this.renderCamera.near, this.renderCamera.far );\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'depthTexture' ].value = this.renderTargetDepthBuffer.texture;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'textureMatrix' ].value = this.textureMatrix;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\t\t\tthis.renderScene.overrideMaterial = null;\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\tthis.renderScene.background = currentBackground;\n\n\t\t\t// 2. Downsample to Half resolution\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\n\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\n\n\t\t\tif ( this.pulsePeriod > 0 ) {\n\n\t\t\t\tconst scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\n\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\n\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\n\n\t\t\t}\n\n\t\t\t// 3. Apply Edge Detection Pass\n\t\t\tthis.fsQuad.material = this.edgeDetectionMaterial;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'texSize' ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'visibleEdgeColor' ].value = this.tempPulseColor1;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'hiddenEdgeColor' ].value = this.tempPulseColor2;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// 4. Apply Blur on Half res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial1;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = this.edgeThickness;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Apply Blur on quarter res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial2;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer2.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Blend it additively over the input texture\n\t\t\tthis.fsQuad.material = this.overlayMaterial;\n\t\t\tthis.overlayMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture1' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture2' ].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'patternTexture' ].value = this.patternTexture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeStrength' ].value = this.edgeStrength;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeGlow' ].value = this.edgeGlow;\n\t\t\tthis.overlayMaterial.uniforms[ 'usePatternTexture' ].value = this.usePatternTexture;\n\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\tgetPrepareMaskMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'depthTexture': { value: null },\n\t\t\t\t'cameraNearFar': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'textureMatrix': { value: null }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\n\t\t\t\t\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t\t\t\t\t#ifdef USE_INSTANCING\n\n\t\t\t\t\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tworldPosition = modelMatrix * worldPosition;\n\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t}\n\n\tgetEdgeDetectionMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'visibleEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t\t'hiddenEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetSeperableBlurMaterial( maxRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'MAX_RADIUS': maxRadius,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'kernelRadius': { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat sigma = kernelRadius/2.0;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, sigma);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = kernelRadius * float(i) / float(MAX_RADIUS);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, sigma);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetOverlayMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'edgeTexture1': { value: null },\n\t\t\t\t'edgeTexture2': { value: null },\n\t\t\t\t'patternTexture': { value: null },\n\t\t\t\t'edgeStrength': { value: 1.0 },\n\t\t\t\t'edgeGlow': { value: 1.0 },\n\t\t\t\t'usePatternTexture': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t}\n\n}\n\nOutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nOutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { OutlinePass };\n","import {\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\nclass ShaderPass extends Pass {\n\n\tconstructor( shader, textureID ) {\n\n\t\tsuper();\n\n\t\tthis.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';\n\n\t\tif ( shader instanceof ShaderMaterial ) {\n\n\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\tthis.material = shader;\n\n\t\t} else if ( shader ) {\n\n\t\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t\tthis.material = new ShaderMaterial( {\n\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\t\tuniforms: this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.fsQuad = new FullScreenQuad( this.material );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis.fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.material.dispose();\n\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n\nexport { ShaderPass };\n","import { Pass } from './Pass.js';\n\nclass MaskPass extends Pass {\n\n\tconstructor( scene, camera ) {\n\n\t\tsuper();\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.clear = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis.inverse = false;\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst context = renderer.getContext();\n\t\tconst state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask( false );\n\t\tstate.buffers.depth.setMask( false );\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked( true );\n\t\tstate.buffers.depth.setLocked( true );\n\n\t\t// set up stencil\n\n\t\tlet writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tstate.buffers.stencil.setTest( true );\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tstate.buffers.stencil.setClear( clearValue );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( writeBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\tstate.buffers.color.setLocked( false );\n\t\tstate.buffers.depth.setLocked( false );\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setLocked( false );\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t}\n\n}\n\nclass ClearMaskPass extends Pass {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.needsSwap = false;\n\n\t}\n\n\trender( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t}\n\n}\n\nexport { MaskPass, ClearMaskPass };\n","import {\n\tClock,\n\tVector2,\n\tWebGLRenderTarget\n} from 'three';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { ShaderPass } from './ShaderPass.js';\nimport { MaskPass } from './MaskPass.js';\nimport { ClearMaskPass } from './MaskPass.js';\n\nclass EffectComposer {\n\n\tconstructor( renderer, renderTarget ) {\n\n\t\tthis.renderer = renderer;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst size = renderer.getSize( new Vector2() );\n\t\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t\t} else {\n\n\t\t\tthis._pixelRatio = 1;\n\t\t\tthis._width = renderTarget.width;\n\t\t\tthis._height = renderTarget.height;\n\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\tthis.renderToScreen = true;\n\n\t\tthis.passes = [];\n\n\t\tthis.copyPass = new ShaderPass( CopyShader );\n\n\t\tthis.clock = new Clock();\n\n\t}\n\n\tswapBuffers() {\n\n\t\tconst tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t}\n\n\taddPass( pass ) {\n\n\t\tthis.passes.push( pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\tinsertPass( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\tremovePass( pass ) {\n\n\t\tconst index = this.passes.indexOf( pass );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.passes.splice( index, 1 );\n\n\t\t}\n\n\t}\n\n\tisLastEnabledPass( passIndex ) {\n\n\t\tfor ( let i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\trender( deltaTime ) {\n\n\t\t// deltaTime value is in seconds\n\n\t\tif ( deltaTime === undefined ) {\n\n\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t}\n\n\t\tconst currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tlet maskActive = false;\n\n\t\tfor ( let i = 0, il = this.passes.length; i < il; i ++ ) {\n\n\t\t\tconst pass = this.passes[ i ];\n\n\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tconst context = this.renderer.getContext();\n\t\t\t\t\tconst stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( MaskPass !== undefined ) {\n\n\t\t\t\tif ( pass instanceof MaskPass ) {\n\n\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\n\n\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\treset( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst size = this.renderer.getSize( new Vector2() );\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\tfor ( let i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t}\n\n\t}\n\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\n\t\tthis.copyPass.dispose();\n\n\t}\n\n}\n\nexport { EffectComposer };\n"],"sourceRoot":""}